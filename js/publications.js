// Publications functionality for Google Scholar integration

// Your Google Scholar user ID
const SCHOLAR_USER_ID = 'xBW0bCcAAAAJ';

// Mock data for fallback when API calls fail
const fallbackPublications = [
    {
        title: "VR for neuroscience research: virtual reality system for studying adaptive visuomotor behavior in mice",
        authors: ["S Hausmann", "M Mathis"],
        venue: "bioRxiv",
        year: "2024",
        citations: 0,
        url: "#"
    },
    {
        title: "Measuring and modeling the motor system with machine learning",
        authors: ["M Mathis", "S Hausmann", "others"],
        venue: "Current Opinion in Neurobiology",
        year: "2021",
        citations: 45,
        url: "https://www.sciencedirect.com/science/article/pii/S0959438821000519"
    }
];

/**
 * Attempt to fetch publications using various methods
 */
async function fetchPublications() {
    try {
        // Method 1: Try to fetch from local JSON file (pre-generated by Python script)
        const publications = await fetchFromLocalJSON();
        if (publications && publications.length > 0) {
            return publications;
        }
    } catch (error) {
        console.warn('Local JSON method failed:', error);
    }

    try {
        // Method 2: Try a local Flask API if running
        const publications = await fetchFromLocalAPI();
        if (publications && publications.length > 0) {
            return publications;
        }
    } catch (error) {
        console.warn('Local API method failed:', error);
    }

    try {
        // Method 3: Try semantic scholar API as an alternative
        const publications = await fetchFromSemanticScholar();
        if (publications && publications.length > 0) {
            return publications;
        }
    } catch (error) {
        console.warn('Semantic Scholar method failed:', error);
    }

    // Fallback to mock data
    console.log('Using fallback publications data');
    return fallbackPublications;
}

/**
 * Fetch publications from local JSON file
 */
async function fetchFromLocalJSON() {
    const response = await fetch('./publications.json');
    if (!response.ok) {
        throw new Error('Publications JSON file not found');
    }
    
    const data = await response.json();
    return data.publications || [];
}

/**
 * Fetch publications from local Flask API
 */
async function fetchFromLocalAPI() {
    const response = await fetch('http://localhost:5000/api/publications');
    if (!response.ok) {
        throw new Error('Local API not available');
    }
    
    const data = await response.json();
    return data.publications || [];
}

/**
 * Parse Google Scholar HTML to extract publication data
 */
function parseScholarHTML(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    const publications = [];
    const publicationRows = doc.querySelectorAll('#gsc_a_b .gsc_a_t');
    
    publicationRows.forEach(row => {
        try {
            const titleLink = row.querySelector('.gsc_a_at');
            const authorsElement = row.querySelector('.gsc_a_at + .gs_gray');
            const venueElement = row.querySelector('.gs_gray + .gs_gray');
            const citationsElement = row.closest('tr')?.querySelector('.gsc_a_c a');
            const yearElement = row.closest('tr')?.querySelector('.gsc_a_y span');
            
            if (titleLink) {
                const publication = {
                    title: titleLink.textContent.trim(),
                    authors: authorsElement ? authorsElement.textContent.trim().split(',').map(a => a.trim()) : [],
                    venue: venueElement ? venueElement.textContent.trim() : '',
                    year: yearElement ? yearElement.textContent.trim() : '',
                    citations: citationsElement ? parseInt(citationsElement.textContent) || 0 : 0,
                    url: titleLink.href || '#'
                };
                publications.push(publication);
            }
        } catch (error) {
            console.warn('Error parsing publication row:', error);
        }
    });
    
    return publications;
}

/**
 * Fetch publications from Semantic Scholar as an alternative
 */
async function fetchFromSemanticScholar() {
    try {
        // Search for author by name (since we can't directly use Google Scholar ID)
        const authorResponse = await fetch('https://api.semanticscholar.org/graph/v1/author/search?query=Sebastien+Hausmann&fields=authorId,name,paperCount');
        const authorData = await authorResponse.json();
        
        if (!authorData.data || authorData.data.length === 0) {
            throw new Error('Author not found in Semantic Scholar');
        }
        
        const authorId = authorData.data[0].authorId;
        
        // Fetch papers for the author
        const papersResponse = await fetch(`https://api.semanticscholar.org/graph/v1/author/${authorId}/papers?fields=title,authors,venue,year,citationCount,url&limit=20`);
        const papersData = await papersResponse.json();
        
        if (!papersData.data) {
            throw new Error('No papers found');
        }
        
        return papersData.data.map(paper => ({
            title: paper.title || 'Untitled',
            authors: paper.authors ? paper.authors.map(a => a.name) : [],
            venue: paper.venue || '',
            year: paper.year ? paper.year.toString() : '',
            citations: paper.citationCount || 0,
            url: paper.url || '#'
        }));
    } catch (error) {
        throw new Error('Semantic Scholar API failed: ' + error.message);
    }
}

/**
 * Render publications in the DOM
 */
function renderPublications(publications) {
    const container = document.getElementById('publications-container');
    const loadingIndicator = document.getElementById('publications-loading');
    const errorMessage = document.getElementById('publications-error');
    
    if (!container) return;
    
    // Clear container
    container.innerHTML = '';
    
    // Sort publications by year (newest first) and then by citations
    publications.sort((a, b) => {
        const yearA = parseInt(a.year) || 0;
        const yearB = parseInt(b.year) || 0;
        if (yearA !== yearB) {
            return yearB - yearA; // Newest first
        }
        return (b.citations || 0) - (a.citations || 0); // Most cited first
    });
    
    // Create publication cards
    publications.forEach(pub => {
        const card = createPublicationCard(pub);
        container.appendChild(card);
    });
    
    // Show container and hide loading
    loadingIndicator.style.display = 'none';
    errorMessage.style.display = 'none';
    container.style.display = 'grid';
    
    // Animate cards in
    const cards = container.querySelectorAll('.publication-card');
    cards.forEach((card, index) => {
        setTimeout(() => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(20px)';
            card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
            setTimeout(() => {
                card.style.opacity = '1';
                card.style.transform = 'translateY(0)';
            }, 100);
        }, index * 100);
    });
}

/**
 * Create a publication card element
 */
function createPublicationCard(publication) {
    const card = document.createElement('div');
    card.className = 'publication-card';
    
    const authorsText = publication.authors.length > 0 
        ? publication.authors.join(', ')
        : 'Authors not available';
    
    const citationsText = publication.citations > 0 
        ? `${publication.citations} citation${publication.citations !== 1 ? 's' : ''}`
        : 'No citations yet';
    
    card.innerHTML = `
        <div class="publication-title">
            ${publication.url && publication.url !== '#' 
                ? `<a href="${publication.url}" target="_blank">${publication.title}</a>`
                : publication.title
            }
        </div>
        <div class="publication-authors">${authorsText}</div>
        ${publication.venue ? `<div class="publication-venue">${publication.venue}</div>` : ''}
        <div class="publication-meta">
            <span class="publication-year">${publication.year || 'Year unknown'}</span>
            <span class="publication-citations">${citationsText}</span>
        </div>
    `;
    
    return card;
}

/**
 * Show error state
 */
function showError() {
    const loadingIndicator = document.getElementById('publications-loading');
    const errorMessage = document.getElementById('publications-error');
    const container = document.getElementById('publications-container');
    
    if (loadingIndicator) loadingIndicator.style.display = 'none';
    if (container) container.style.display = 'none';
    if (errorMessage) errorMessage.style.display = 'block';
}

/**
 * Initialize publications section
 */
async function initPublications() {
    try {
        const publications = await fetchPublications();
        if (publications && publications.length > 0) {
            renderPublications(publications);
        } else {
            showError();
        }
    } catch (error) {
        console.error('Failed to load publications:', error);
        showError();
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Check if we're on a page that has the publications section
    if (document.getElementById('publications-container')) {
        initPublications();
    }
});

// Export for use in other scripts
window.PublicationsModule = {
    init: initPublications,
    fetch: fetchPublications,
    render: renderPublications
}; 